<template>
  <v-data-table :headers="headers" :items="points">
    <template v-slot:item.label="props">
      <v-edit-dialog
        :return-value.sync="props.item.label"
        @close="close(props.item)"
      >
        {{ props.item.label }}
        <template v-slot:input>
          <v-text-field
            v-model="props.item.label"
            :rules="[max25chars]"
            label="Edit"
            single-line
            counter
          />
        </template>
      </v-edit-dialog>
    </template>

    <template v-if="showFrame" v-slot:item.time="props">
      {{ $vuewer.math.round(props.item.frame.time, 3) }}
    </template>

    <template v-slot:item.x="props">
      {{ Math.round((props.item.x / cw) * ow) }}
    </template>
    <template v-slot:item.y="props">
      {{ Math.round((props.item.y / ch) * oh) }}
    </template>
    <template v-slot:item.color="props">
      <m-color-menu
        icon
        v-model="props.item.color"
        @input="close(props.item)"
      />
    </template>
  </v-data-table>
</template>
<script>
import MColorMenu from "@/components/menus/MColorMenu";
export default {
  name: "m-point-table",
  components: { MColorMenu },
  props: {
    showFrame: {
      type: Boolean,
      default: false
    },
    points: {
      type: Array,
      require: true
    },
    originSize: {
      type: Object,
      require: true
    },
    canvasSize: {
      type: Object,
      require: true
    }
  },
  computed: {
    ow: function() {
      return this.originSize.width ? this.originSize.width : 0;
    },
    oh: function() {
      return this.originSize.height ? this.originSize.height : 0;
    },
    cw: function() {
      return this.canvasSize.width ? this.canvasSize.width : 0;
    },
    ch: function() {
      return this.canvasSize.height ? this.canvasSize.width : 0;
    },
    headers: function() {
      if (this.showFrame) {
        return [
          { text: "label", value: "label" },
          { text: "frame", value: "frame.idx" },
          { text: "time", value: "time" },
          { text: "x", value: "x" },
          { text: "y", value: "y" },
          { text: "color", value: "color" }
        ];
      }
      return [
        { text: "label", value: "label" },
        { text: "x", value: "x" },
        { text: "y", value: "y" },
        { text: "color", value: "color" }
      ];
    }
  },
  data: () => ({
    max25chars: v => v.length <= 25 || "Input too long!",
    pagination: {}
  }),
  methods: {
    close(item) {
      this.$emit("update-point", item);
    }
  }
};
</script>

<style scoped></style>
